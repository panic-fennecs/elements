[gd_scene load_steps=4 format=2]

[ext_resource path="res://src/level/ElementRenderer.gd" type="Script" id=1]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;
render_mode unshaded;

uniform float elapsed_time;
uniform sampler3D fluid_tex;
uniform sampler2D solid_tex;

float smin( float a, float b, float k )
{
    float h = max( k-abs(a-b), 0.0 )/k;
    return min( a, b ) - h*h*k*(1.0/4.0);
}

float smin2( float a, float b, float k )
{
    float res = exp2( -k*a ) + exp2( -k*b );
    return -log2( res )/k;
}

float circle(vec2 p) {
	return length(p);
}

float rectangle(vec2 p, vec2 r)
{
	return length(max(vec2(0), abs(p) - r));
	//p = abs(p) - r;
	//return max(p.x, p.y);
}

vec3 blend(vec3 prev, vec4 next)
{
	return mix(prev, next.xyz, next.a);
}

float n21(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float bedrock(vec2 sv) {
	const float r = 2.;
	vec2 size = vec2(textureSize(solid_tex, 0).xy);
	vec2 id = floor(sv * size);
	vec2 gv = fract(sv * size) - .5;
	float d = 1000.;
	vec2 uv = gv;
	
	for (float x = max(0., id.x - r); x <= min(size.x - 1., id.x + r); ++x) {
		for (float y = max(0., id.y - r); y <= min(size.y - 1., id.y + r); ++y) {
			if (vec2(x, y) == id)
				continue;
				
			vec2 tx = (vec2(.5) + vec2(x, y)) / size;
			bool solid = texture(solid_tex, tx).r == 3.;
			if (solid) {
				vec2 v = vec2(x, y) - id + gv;
				uv += .1 * v / r;
			}
		}
	}
	
	for (float x = max(0., id.x - r); x <= min(size.x - 1., id.x + r); ++x) {
		for (float y = max(0., id.y - r); y <= min(size.y - 1., id.y + r); ++y) {
			vec2 tx = (vec2(.5) + vec2(x, y)) / size + uv - id;
			bool solid = texture(solid_tex, tx).r == 3.;
			if (solid) {
				d = min(d, rectangle(uv, vec2(.5)));
			}
		}
	}
	//return d / size.y;
	return texture(solid_tex, sv).r == 3. ? -1. : 1.;
	return texture(solid_tex, sv).r == 3. ? rectangle(uv, vec2(1.)) / size.x : 1000.;
}

float bedrock_deco(vec2 sv) {
	const float r = 2.;
	vec2 size = vec2(textureSize(solid_tex, 0).xy);
	vec2 id = floor(sv * size);
	vec2 gv = fract(sv * size) - .5;
	float d = 1000.;
	vec2 uv = gv;
	
	for (float x = max(0., id.x - r); x <= min(size.x - 1., id.x + r); ++x) {
		for (float y = max(0., id.y - r); y <= min(size.y - 1., id.y + r); ++y) {
			if (vec2(x, y) == id)
				continue;
				
			vec2 tx = (vec2(.5) + vec2(x, y)) / size;
			bool solid = texture(solid_tex, tx).r == 3.;
			if (solid) {
				vec2 v = vec2(x, y) - id + gv;
				uv += v * .1;
			}
		}
	}
	
	return texture(solid_tex, sv).r == 3. ? 0. : (rectangle(uv, vec2(.5)) > 0. ? 0. : 1.);
}

void fragment() {
	float aspect_ratio = 16. / 9.;
	vec2 aspect = vec2(aspect_ratio, 1);
	vec2 sv = UV.xy;
	vec2 uv = sv * aspect;
	vec2 solid_tex_size = vec2(textureSize(solid_tex, 0).xy);
	vec3 fluid_tex_size = vec3(textureSize(fluid_tex, 0).xyz);
	// pixelate
	//uv = floor(uv * fluid_tex_size.y * 16.) / fluid_tex_size.y / 16.;
	vec2 solid_id = floor(sv * solid_tex_size);
	vec2 solid_gv = fract(sv * solid_tex_size) - .5;
	vec2 fluid_id = floor(sv * fluid_tex_size.xy);
	//COLOR = vec4(vec3(.09, .17, .22), 1);
	COLOR = vec4(vec3(.45, .62, .22) * .8, 1);
	//COLOR = vec4(fluid_id.xy / fluid_tex_size.xy, .22, 1);
	
	// solid shadow
	float dshadow = bedrock(sv - vec2(1, 1.4) / solid_tex_size);
	COLOR.rgb = blend(COLOR.rgb, vec4(vec3(.05), dshadow < 0. ? .6 : 0.));
	
	// fluids

	const float radius = 1.;
	float d2[2] = {1000., 1000.};
	float sum[2] = {0., 0.};
	
	for (float x = max(0., fluid_id.x - radius); x <= min(fluid_tex_size.x - 1., fluid_id.x + radius); ++x) {
		for (float y = max(0., fluid_id.y - radius); y <= min(fluid_tex_size.y - 1., fluid_id.y + radius); ++y) {
			for (float z = 0.; z < fluid_tex_size.z; ++z) {
				vec3 tx = (vec3(.5) + vec3(x, y, z)) / fluid_tex_size;
				vec4 fluid = texture(fluid_tex, tx);
				if (fluid.b == 0.)
					break;
				int index = int(fluid.b)-1;
				d2[index] = smin(d2[index], circle(uv - fluid.xy * aspect) - .01, .07);
				sum[index] += max(0., 1. - circle(uv - fluid.xy * aspect) * fluid_tex_size.y);
				//d = min(d, circle(uv - fluid.xy * aspect) - .01);
			}
		}
	}

	float depth = min(1., sum[0] * sum[0] * .01);
	float wave = smoothstep(.002 + .02 * (1. - depth), .001, -d2[0]) * abs(sin(d2[0] * 337. - elapsed_time * 1.87) + sin(d2[0] * 700. + elapsed_time) * .5);
	vec3 border_color = vec3(.5, .6, .8);
	vec3 deep_color = vec3(.1, .2, .6) * (1.5 - depth) + wave * .5;

	COLOR.rgb = blend(COLOR.rgb, vec4(
		mix(
			border_color,
			deep_color,
			clamp(0., 1., -d2[0] * 100.)
		),
		smoothstep(SCREEN_PIXEL_SIZE.y * 2., .0, d2[0])));

	depth = min(1., sum[1] * sum[1] * .01);
	wave = smoothstep(.002 + .02 * (1. - depth), .001, -d2[1]) * abs(sin(d2[1] * 337. - elapsed_time * 1.87) + sin(d2[1] * 700. + elapsed_time) * .5);
	border_color = vec3(.8, .6, .5);
	deep_color = vec3(.6, .2, .1) * (1.5 - depth) + wave * .5;

	COLOR.rgb = blend(COLOR.rgb, vec4(
		mix(
			border_color,
			deep_color,
			clamp(0., 1., -d2[1] * 100.)
		),
		smoothstep(SCREEN_PIXEL_SIZE.y * 2., .0, d2[1])));

	// solids

	vec4 solid = texture(solid_tex, sv);
	if (solid.r > 0.) {
		switch(int(solid.r)) {
		case 1: // ice
			float highlight = sin((uv.x * 1.3 + uv.y) * 100.) * 1.8;
			highlight = min(1., highlight) - fract(max(0., highlight - 1.)); // fold
			highlight = highlight > .75 ? 1. : 0.;
			highlight *= sin((uv.x + uv.y * .12) * 60.) * .5 + .5;
			highlight *= sin((uv.y + uv.x * .42) * 40.) * .5 + .5;
			COLOR.rgb = blend(COLOR.rgb, vec4(vec3(.1, .6, .9) * vec3(1. + .2 * highlight), 1.));
			break;
		case 2: // obsidian
			COLOR.rgb = blend(COLOR.rgb, vec4(vec3(.35, .02, .15), 1.));
			break;
		}
		
	}
	
	/*
	float dbedrock = bedrock_deco(sv);
	COLOR.rgb = blend(COLOR.rgb, vec4(
		2. * vec3(.2, .1, .1),
		smoothstep(SCREEN_PIXEL_SIZE.y * 2., 0., dbedrock)
	));*/
	
	float dbedrock_deco = bedrock(sv);
	float rough_noise = .8 + .2 * n21(floor(uv * 73.) / 73.);
	COLOR.rgb = blend(COLOR.rgb, vec4(
		rough_noise * vec3(.2, .1, .1),
		smoothstep(SCREEN_PIXEL_SIZE.y * 2., 0., dbedrock_deco)
	));
	
	// noise
	COLOR.rgb = blend(COLOR.rgb, vec4(vec3(n21(floor(uv * 800.) / 800.)), .07));
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/elapsed_time = null

[node name="ElementRenderer" type="Node2D"]
script = ExtResource( 1 )
__meta__ = {
"_edit_lock_": true
}

[node name="Canvas" type="ColorRect" parent="."]
material = SubResource( 2 )
margin_right = 1280.0
margin_bottom = 720.0
size_flags_horizontal = 0
size_flags_vertical = 0
__meta__ = {
"_edit_lock_": true,
"_edit_use_anchors_": false
}
