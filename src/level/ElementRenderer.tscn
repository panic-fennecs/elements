[gd_scene load_steps=4 format=2]

[ext_resource path="res://src/level/ElementRenderer.gd" type="Script" id=1]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;
render_mode unshaded;

uniform float elapsed_time;
uniform sampler3D fluid_tex;
uniform sampler2D solid_tex;

float smin( float a, float b, float k )
{
    float h = max( k-abs(a-b), 0.0 )/k;
    return min( a, b ) - h*h*k*(1.0/4.0);
}

float circle(vec2 p) {
	return length(p);
}

void fragment() {
	float aspect_ratio = 16. / 9.;
	vec2 aspect = vec2(aspect_ratio, 1);
	vec2 uv = UV.xy * aspect;
	vec3 fluid_tex_size = vec3(textureSize(fluid_tex, 0).xyz);
	// pixelate
	//uv = floor(uv * fluid_tex_size.y * 16.) / fluid_tex_size.y / 16.;
	vec2 fluid_id = floor(UV.xy * fluid_tex_size.xy);
	COLOR = vec4(.09, .17, .22, 1);
	//COLOR = vec4(fluid_id.xy / fluid_tex_size.xy, .22, 1);

	vec4 solid = texture(solid_tex, UV.xy);
	if (solid.r > 0.) {
		float highlight = sin((uv.x + uv.y) * 50.) * 1.8;
		highlight = min(1., highlight) - fract(max(0., highlight - 1.)); // fold
		highlight = highlight > .85 ? 1. : 0.;
		highlight *= sin((uv.x + uv.y * .12) * 60.) * .5 + .5;
		highlight *= sin((uv.y + uv.x * .42) * 40.) * .5 + .5;
		
		vec3 color;
		switch(int(solid.r)) {
		case 1: // ice
			color = vec3(.1, .6, .9);
			break;
		case 2: // obsidian
			color = vec3(.35, .02, .15);
			break;
		case 3: // bedrock
			color = vec3(.2, .3, .25);
			break;
		}
		
		COLOR.rgb += color * vec3(1. + .1 * highlight);
	} else {
		const float radius = 1.;
		float d[2] = {1000., 1000.};
		float sum[2] = {0., 0.};
		
		for (float x = max(0., fluid_id.x - radius); x <= min(fluid_tex_size.x - 1., fluid_id.x + radius); ++x) {
			for (float y = max(0., fluid_id.y - radius); y <= min(fluid_tex_size.y - 1., fluid_id.y + radius); ++y) {
				for (float z = 0.; z < fluid_tex_size.z; ++z) {
					vec3 tx = (vec3(.5) + vec3(x, y, z)) / fluid_tex_size;
					vec4 fluid = texture(fluid_tex, tx);
					if (fluid.b == 0.)
						break;
					int index = int(fluid.b)-1;
					d[index] = smin(d[index], circle(uv - fluid.xy * aspect) - .025, .05);
					sum[index] += max(0., 1. - circle(uv - fluid.xy * aspect) * fluid_tex_size.y);
					//d = min(d, circle(uv - fluid.xy * aspect) - .01);
				}
			}
		}

		float height = sin((uv.x + uv.y) * 20. + elapsed_time * 5.) * .5 + .5 + sum[0] * sum[0] * .02;
		vec3 border_color = vec3(.2, .5, .8);
		vec3 deep_color = vec3(.1, .2, .6) * (1. + height * .5);

		COLOR.rgb += mix(
				border_color,
				deep_color,
				clamp(0., 1., -d[0] * 100.))
			* smoothstep(SCREEN_PIXEL_SIZE.y, .0, d[0]);
			
		height = sin((uv.x + uv.y) * 20. + elapsed_time * 5.) * .5 + .5 + sum[1] * sum[1] * .1;
		border_color = vec3(.8, .2, .15);
		deep_color = vec3(.5, .1, .06) * (1. + height * .1);
		COLOR.rgb += mix(
				border_color,
				deep_color,
				clamp(0., 1., -d[1] * 100.))
			* smoothstep(SCREEN_PIXEL_SIZE.y, .0, d[1]);
	}
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/elapsed_time = null

[node name="ElementRenderer" type="Node2D"]
script = ExtResource( 1 )
__meta__ = {
"_edit_lock_": true
}

[node name="Canvas" type="ColorRect" parent="."]
material = SubResource( 2 )
margin_right = 1280.0
margin_bottom = 720.0
size_flags_horizontal = 0
size_flags_vertical = 0
__meta__ = {
"_edit_lock_": true,
"_edit_use_anchors_": false
}
